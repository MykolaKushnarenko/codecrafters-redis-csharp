using System.Text;
using DotRedis.BuildingBlocks.CommandResults;
using DotRedis.BuildingBlocks.Commands;

namespace DotRedis.BuildingBlocks.Handlers;

/// <summary>
///     Handles the processing of the PSYNC command within the Redis-like system.
/// </summary>
/// <remarks>
///     The <c>PsyncCommandHandler</c> is responsible for managing the PSYNC command by providing
///     the necessary stream results or outputs for the command like the RDD snapshot.
///     Redis link: https://redis.io/docs/latest/commands/psync/
/// </remarks>
public class PsyncCommandHandler : ICommandHandler<Command>
{
    public string HandlingCommandName => Constants.PsyncCommand;
    
    public Task<CommandResult> HandleAsync(Command command, CancellationToken cancellationToken)
    {
        return Task.FromResult<CommandResult>(StreamResult.Create(GetStream()));
    }
    
    private IEnumerable<CommandResult> GetStream()
    {
        //TODO: implement this properly. Id should be autogenerated (40 chars), and offset should be not 0.
        // Here we only handle "PSYNC", "?", "-1"
        // tt is "?" because this is the first time the replica is connecting to the master
        // it is -1 because this is the first time the replica is connecting to the master.
        yield return SimpleStringResult.Create("FULLRESYNC 8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb 0");
        
        // This is hard-coded empty RDB file.
        // We need to generate a real RDB file and send it to the replica.
        var fileToReplicate =
            Convert.FromBase64String(
                "UkVESVMwMDEx+glyZWRpcy12ZXIFNy4yLjD6CnJlZGlzLWJpdHPAQPoFY3RpbWXCbQi8ZfoIdXNlZC1tZW3CsMQQAPoIYW9mLWJhc2XAAP/wbjv+wP9aog==");
        string header = $"${fileToReplicate.Length}\r\n";
        byte[] headerBytes = Encoding.UTF8.GetBytes(header);
    
        // Combine header and binary data
        byte[] transmission = new byte[headerBytes.Length + fileToReplicate.Length];
        Buffer.BlockCopy(headerBytes, 0, transmission, 0, headerBytes.Length);
        Buffer.BlockCopy(fileToReplicate, 0, transmission, headerBytes.Length, fileToReplicate.Length);
        
        yield return TransmissionResult.Create(transmission);
    }
}